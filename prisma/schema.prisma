// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// CLIENTS & SUBSCRIPTIONS
// ============================================================================

model Client {
  id              String    @id @default(cuid())
  tier            ClientTier
  name            String
  orgNo           String    @unique
  contacts        Contact[]
  subscriptions   Subscription[]
  dataFeeds       DataFeed[]
  tasks           Task[]
  reports         Report[]
  riskProfiles    RiskProfile[]
  kycRecords      KYCRecord[]
  bankAccounts    BankAccount[]
  investors       Investor[]
  users           User[] @relation("UserToClient")
  ledgers         LedgerEntry[] @relation("ClientLedgers")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([tier])
  @@index([orgNo])
}

enum ClientTier {
  XL
  LARGE
}

model Subscription {
  id          String    @id @default(cuid())
  clientId    String
  client      Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  plan        Plan
  active      Boolean   @default(true)
  sla         String?   // e.g. "T+3" for NAV deadline
  startedAt   DateTime  @default(now())
  endedAt     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([clientId, plan])
  @@index([clientId])
}

enum Plan {
  AGENT_PORTAL
  COORDINATOR
  SPECIALIST
}

model Contact {
  id        String   @id @default(cuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  email     String
  name      String
  role      String?  // e.g. "CFO", "COO"
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clientId, email])
  @@index([clientId])
}

// ============================================================================
// USERS & RBAC
// ============================================================================

model User {
  id              String    @id @default(cuid())
  role            Role
  email           String    @unique
  name            String
  password        String?   // For NextAuth credentials provider
  image           String?
  emailVerified   DateTime?
  clientId        String?   // If CLIENT, link to client
  client          Client?   @relation("UserToClient", fields: [clientId], references: [id])
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  auditLogs       AuditLog[] @relation("AuditActors")
  accounts        Account[]
  sessions        Session[]
  tasks           Task[] @relation("UserTasks")

  @@index([role])
  @@index([email])
}

enum Role {
  CLIENT
  COORDINATOR
  SPECIALIST
  ADMIN
}

model Account {
  id                 String    @id @default(cuid())
  userId             String
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
  createdAt    DateTime @default(now())

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Relation extension (avoid circular FK)
model UserToClient {
  id String @id @default(cuid())
}

// ============================================================================
// DATA FEEDS & ETL
// ============================================================================

model DataFeed {
  id          String      @id @default(cuid())
  clientId    String
  client      Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)
  source      DataSource
  status      FeedStatus  @default(ACTIVE)
  lastSyncAt  DateTime?
  lastError   String?
  configJson  Json
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@unique([clientId, source])
  @@index([clientId])
  @@index([status])
}

enum DataSource {
  FORTNOX
  ALLVUE
  BANK
  SKV
  FI
  SIGMA
  MANUAL
}

enum FeedStatus {
  ACTIVE
  ERROR
  PAUSED
}

// ============================================================================
// LEDGER & TRANSACTIONS
// ============================================================================

model LedgerEntry {
  id          String    @id @default(cuid())
  clientId    String
  client      Client    @relation("ClientLedgers", fields: [clientId], references: [id], onDelete: Cascade)
  source      DataSource
  bookingDate DateTime
  account     String
  amount      Decimal
  currency    String    @db.VarChar(3)
  description String?
  meta        Json?
  createdAt   DateTime  @default(now())

  @@index([clientId])
  @@index([bookingDate])
  @@index([account])
}

model BankAccount {
  id        String   @id @default(cuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  iban      String
  currency  String   @db.VarChar(3)
  balance   Decimal
  syncedAt  DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clientId, iban])
  @@index([clientId])
}

// ============================================================================
// TASKS (QC, KYC, Reports, etc.)
// ============================================================================

model Task {
  id          String      @id @default(cuid())
  clientId    String
  client      Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)
  kind        TaskKind
  status      TaskStatus  @default(QUEUED)
  payload     Json
  assigneeId  String?
  assignee    User?       @relation("UserTasks", fields: [assigneeId], references: [id])
  comment     String?
  flags       Flag[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  dueAt       DateTime?

  @@index([clientId])
  @@index([status])
  @@index([kind])
  @@index([dueAt])
}

enum TaskKind {
  QC_CHECK
  KYC_REVIEW
  REPORT_DRAFT
  BANK_RECON
  RISK_CALC
  COMPLIANCE_CHECK
  INVESTOR_ONBOARD
}

enum TaskStatus {
  QUEUED
  IN_PROGRESS
  BLOCKED
  NEEDS_REVIEW
  DONE
}

model Flag {
  id          String   @id @default(cuid())
  taskId      String
  task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  severity    String   // "error", "warning", "info"
  message     String
  code        String?  // e.g. "BANK_MISMATCH", "MISSING_KYC"
  context     Json?    // e.g. { lineNumber, amount, account }
  createdAt   DateTime @default(now())

  @@index([taskId])
}

// ============================================================================
// REPORTS
// ============================================================================

model Report {
  id            String        @id @default(cuid())
  clientId      String
  client        Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  type          ReportType
  periodStart   DateTime
  periodEnd     DateTime
  status        ReportStatus  @default(DRAFT)
  draftText     String?       // AI-generated Markdown/HTML
  finalText     String?       // Specialist-approved text
  artifactUrl   String?       // S3 URL to PDF
  draftMetrics  Json?         // { nav: 100M, inflow: 5M, ... }
  evidence      Evidence?     @relation("ReportEvidence")
  versions      ReportVersion[]
  signOffs      SignOff[]
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@unique([clientId, type, periodStart, periodEnd])
  @@index([clientId])
  @@index([status])
}

enum ReportType {
  FUND_ACCOUNTING
  INVESTOR_REPORT
  FINANCIAL
  REGULATORY
}

enum ReportStatus {
  DRAFT
  QC
  APPROVAL
  PUBLISHED
}

model ReportVersion {
  id        String   @id @default(cuid())
  reportId  String
  report    Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  versionNo Int
  text      String
  createdAt DateTime @default(now())

  @@unique([reportId, versionNo])
}

// ============================================================================
// EVIDENCE & IMMUTABLE DOCS (S3 Object Lock)
// ============================================================================

model Evidence {
  id         String   @id @default(cuid())
  reportId   String   @unique
  report     Report   @relation("ReportEvidence", fields: [reportId], references: [id], onDelete: Cascade)
  s3Url      String   // immutable S3 object lock
  fileHash   String   // SHA256 of contents
  createdAt  DateTime @default(now())
}

// ============================================================================
// SIGN-OFF & ATTESTATION
// ============================================================================

model SignOff {
  id         String   @id @default(cuid())
  reportId   String
  report     Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  userId     String
  role       Role
  timestamp  DateTime @default(now())
  esignUrl   String?  // BankID/DocuSign artifact

  @@unique([reportId, userId])
}

// ============================================================================
// KYC & COMPLIANCE
// ============================================================================

model KYCRecord {
  id              String   @id @default(cuid())
  clientId        String
  client          Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  investorId      String?  @unique
  investor        Investor? @relation(fields: [investorId], references: [id])
  status          KYCStatus @default(PENDING)
  riskLevel       String?  // "low", "medium", "high"
  pepStatus       String?  // "clear", "flagged"
  sanctionStatus  String?  // "clear", "flagged"
  documentUrl     String?  // S3 URL
  uboTree         Json?    // { owners: [{name, ownership%}] }
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([clientId])
  @@index([status])
}

enum KYCStatus {
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
  EXPIRED
}

model RiskProfile {
  id           String   @id @default(cuid())
  clientId     String
  client       Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  period       DateTime
  var95        Decimal? // Value at Risk
  concentration Json?   // top5 positions
  limitBreaches Json?   // { limit: "X", breach: true/false }
  stressTest   Json?   // scenario results
  createdAt    DateTime @default(now())

  @@unique([clientId, period])
  @@index([clientId])
}

// ============================================================================
// INVESTORS (for onboarding)
// ============================================================================

model Investor {
  id        String   @id @default(cuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name      String
  email     String
  ubo       String?  // Ultimate Beneficial Owner info
  kycRecord KYCRecord?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clientId, email])
  @@index([clientId])
}

// ============================================================================
// AUDIT LOG
// ============================================================================

model AuditLog {
  id        String   @id @default(cuid())
  actorId   String?
  actor     User?    @relation("AuditActors", fields: [actorId], references: [id])
  actorRole Role?
  action    String   // "CREATE", "UPDATE", "DELETE", "APPROVE", etc.
  refType   String   // "Report", "Task", "DataFeed", etc.
  refId     String
  diffJson  Json?    // { before: {...}, after: {...} }
  ip        String?
  createdAt DateTime @default(now())

  @@index([refType, refId])
  @@index([actorId])
  @@index([createdAt])
}
