// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// CLIENTS & SUBSCRIPTIONS
// ============================================================================

model Client {
  id            String         @id @default(cuid())
  tier          ClientTier
  name          String
  orgNo         String         @unique
  contacts      Contact[]
  subscriptions Subscription[]
  dataFeeds     DataFeed[]
  tasks         Task[]
  reports       Report[]
  riskProfiles  RiskProfile[]
  kycRecords    KYCRecord[]
  bankAccounts  BankAccount[]
  investors     Investor[]
  users         User[]         @relation("UserToClient")
  ledgers       LedgerEntry[]  @relation("ClientLedgers")
  documents     Document[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@index([tier])
  @@index([orgNo])
}

enum ClientTier {
  XL
  LARGE
}

model Subscription {
  id        String    @id @default(cuid())
  clientId  String
  client    Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  plan      Plan
  active    Boolean   @default(true)
  sla       String? // e.g. "T+3" for NAV deadline
  startedAt DateTime  @default(now())
  endedAt   DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([clientId, plan])
  @@index([clientId])
}

enum Plan {
  AGENT_PORTAL
  COORDINATOR
  SPECIALIST
}

model Contact {
  id        String   @id @default(cuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  email     String
  name      String
  role      String? // e.g. "CFO", "COO"
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clientId, email])
  @@index([clientId])
}

// ============================================================================
// USERS & RBAC
// ============================================================================

model User {
  id            String           @id @default(cuid())
  role          Role
  email         String           @unique
  name          String
  password      String? // For NextAuth credentials provider
  image         String?
  emailVerified DateTime?
  clientId      String? // If CLIENT, link to client
  client        Client?          @relation("UserToClient", fields: [clientId], references: [id])
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  auditLogs     AuditLog[]       @relation("AuditActors")
  accounts      Account[]
  sessions      Session[]
  tasks         Task[]           @relation("UserTasks")
  conversations AIConversation[] @relation("UserConversations")

  @@index([role])
  @@index([email])
}

enum Role {
  CLIENT
  COORDINATOR
  SPECIALIST
  ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
  createdAt    DateTime @default(now())

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Relation extension (avoid circular FK)
model UserToClient {
  id String @id @default(cuid())
}

// ============================================================================
// DATA FEEDS & ETL
// ============================================================================

model DataFeed {
  id         String     @id @default(cuid())
  clientId   String
  client     Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  source     DataSource
  status     FeedStatus @default(ACTIVE)
  lastSyncAt DateTime?
  lastError  String?
  configJson Json
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@unique([clientId, source])
  @@index([clientId])
  @@index([status])
}

enum DataSource {
  FORTNOX
  ALLVUE
  BANK
  SKV
  FI
  SIGMA
  MANUAL
}

enum FeedStatus {
  ACTIVE
  ERROR
  PAUSED
}

// ============================================================================
// LEDGER & TRANSACTIONS
// ============================================================================

model LedgerEntry {
  id          String     @id @default(cuid())
  clientId    String
  client      Client     @relation("ClientLedgers", fields: [clientId], references: [id], onDelete: Cascade)
  source      DataSource
  bookingDate DateTime
  account     String
  amount      Decimal
  currency    String     @db.VarChar(3)
  description String?
  meta        Json?
  createdAt   DateTime   @default(now())

  @@index([clientId])
  @@index([bookingDate])
  @@index([account])
}

model BankAccount {
  id        String    @id @default(cuid())
  clientId  String
  client    Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  iban      String
  currency  String    @db.VarChar(3)
  balance   Decimal
  syncedAt  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([clientId, iban])
  @@index([clientId])
}

// ============================================================================
// TASKS (QC, KYC, Reports, etc.)
// ============================================================================

model Task {
  id         String     @id @default(cuid())
  clientId   String
  client     Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  kind       TaskKind
  status     TaskStatus @default(QUEUED)
  payload    Json
  assigneeId String?
  assignee   User?      @relation("UserTasks", fields: [assigneeId], references: [id])
  comment    String?
  flags      Flag[]
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  dueAt      DateTime?

  @@index([clientId])
  @@index([status])
  @@index([kind])
  @@index([dueAt])
}

enum TaskKind {
  QC_CHECK
  KYC_REVIEW
  REPORT_DRAFT
  BANK_RECON
  RISK_CALC
  COMPLIANCE_CHECK
  INVESTOR_ONBOARD
}

enum TaskStatus {
  QUEUED
  IN_PROGRESS
  BLOCKED
  NEEDS_REVIEW
  DONE
}

model Flag {
  id        String   @id @default(cuid())
  taskId    String
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  severity  String // "error", "warning", "info"
  message   String
  code      String? // e.g. "BANK_MISMATCH", "MISSING_KYC"
  context   Json? // e.g. { lineNumber, amount, account }
  createdAt DateTime @default(now())

  @@index([taskId])
}

// ============================================================================
// REPORTS
// ============================================================================

model Report {
  id           String          @id @default(cuid())
  clientId     String
  client       Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  type         ReportType
  periodStart  DateTime
  periodEnd    DateTime
  status       ReportStatus    @default(DRAFT)
  draftText    String? // AI-generated Markdown/HTML
  finalText    String? // Specialist-approved text
  artifactUrl  String? // S3 URL to PDF
  draftMetrics Json? // { nav: 100M, inflow: 5M, ... }
  evidence     Evidence?       @relation("ReportEvidence")
  versions     ReportVersion[]
  signOffs     SignOff[]
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  @@unique([clientId, type, periodStart, periodEnd])
  @@index([clientId])
  @@index([status])
}

enum ReportType {
  FUND_ACCOUNTING
  INVESTOR_REPORT
  FINANCIAL
  REGULATORY
}

enum ReportStatus {
  DRAFT
  QC
  APPROVAL
  PUBLISHED
}

model ReportVersion {
  id        String   @id @default(cuid())
  reportId  String
  report    Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  versionNo Int
  text      String
  createdAt DateTime @default(now())

  @@unique([reportId, versionNo])
}

// ============================================================================
// EVIDENCE & IMMUTABLE DOCS (S3 Object Lock)
// ============================================================================

model Evidence {
  id        String   @id @default(cuid())
  reportId  String   @unique
  report    Report   @relation("ReportEvidence", fields: [reportId], references: [id], onDelete: Cascade)
  s3Url     String // immutable S3 object lock
  fileHash  String // SHA256 of contents
  createdAt DateTime @default(now())
}

// ============================================================================
// SIGN-OFF & ATTESTATION
// ============================================================================

model SignOff {
  id        String   @id @default(cuid())
  reportId  String
  report    Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  userId    String
  role      Role
  timestamp DateTime @default(now())
  esignUrl  String? // BankID/DocuSign artifact

  @@unique([reportId, userId])
}

// ============================================================================
// KYC & COMPLIANCE
// ============================================================================

model KYCRecord {
  id             String    @id @default(cuid())
  clientId       String
  client         Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  investorId     String?   @unique
  investor       Investor? @relation(fields: [investorId], references: [id])
  status         KYCStatus @default(PENDING)
  riskLevel      String? // "low", "medium", "high"
  pepStatus      String? // "clear", "flagged"
  sanctionStatus String? // "clear", "flagged"
  documentUrl    String? // S3 URL
  uboTree        Json? // { owners: [{name, ownership%}] }
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([clientId])
  @@index([status])
}

enum KYCStatus {
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
  EXPIRED
}

model RiskProfile {
  id            String   @id @default(cuid())
  clientId      String
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  period        DateTime
  var95         Decimal? // Value at Risk
  concentration Json? // top5 positions
  limitBreaches Json? // { limit: "X", breach: true/false }
  stressTest    Json? // scenario results
  createdAt     DateTime @default(now())

  @@unique([clientId, period])
  @@index([clientId])
}

// ============================================================================
// INVESTORS (for onboarding)
// ============================================================================

model Investor {
  id        String     @id @default(cuid())
  clientId  String
  client    Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name      String
  email     String
  ubo       String? // Ultimate Beneficial Owner info
  kycRecord KYCRecord?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@unique([clientId, email])
  @@index([clientId])
}

// ============================================================================
// AUDIT LOG
// ============================================================================

model AuditLog {
  id        String   @id @default(cuid())
  actorId   String?
  actor     User?    @relation("AuditActors", fields: [actorId], references: [id])
  actorRole Role?
  action    String // "CREATE", "UPDATE", "DELETE", "APPROVE", etc.
  refType   String // "Report", "Task", "DataFeed", etc.
  refId     String
  diffJson  Json? // { before: {...}, after: {...} }
  ip        String?
  createdAt DateTime @default(now())

  @@index([refType, refId])
  @@index([actorId])
  @@index([createdAt])
}

// ============================================================================
// DOCUMENT MANAGEMENT (Compliance & Q&A)
// ============================================================================

model Document {
  id       String  @id @default(cuid())
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: Cascade)

  // File information
  fileName   String
  fileType   String // MIME type: "application/pdf", "image/png", etc.
  fileSize   Int // Size in bytes
  storageKey String // Key in storage (S3 or local)
  storageUrl String // URL to access file
  fileHash   String // SHA256 hash for integrity

  // Classification
  documentType String? // "policy", "regulation", "report", "evidence", etc.
  category     String? // "compliance", "legal", "financial", etc.
  version      String? // Document version
  language     String? @default("sv") // Document language

  // Metadata
  title         String?
  description   String?   @db.Text
  author        String?
  publishDate   DateTime?
  effectiveDate DateTime?
  expiryDate    DateTime?
  tags          String[]

  // Extraction
  extractedText     String? @db.Text // OCR/parsed text content
  extractedMetadata Json? // Structured metadata from document

  // Indexing
  embedding String? // Vector embedding for RAG (JSON array as string)
  indexedAt DateTime? // When document was indexed

  // Compliance
  policyChecks Json? // Results of policy compliance checks
  gaps         Json? // Identified gaps in compliance

  // Status
  status     DocumentStatus @default(PENDING)
  uploadedBy String? // User ID who uploaded
  uploadedAt DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  // Relations
  complianceChecks ComplianceCheck[]
  questions        DocumentQuestion[]
  Policy           Policy?            @relation(fields: [policyId], references: [id])
  policyId         String?

  @@index([clientId])
  @@index([documentType])
  @@index([category])
  @@index([status])
  @@index([storageKey])
  @@index([tags])
  @@index([indexedAt])
}

enum DocumentStatus {
  PENDING // Uploaded but not processed
  PROCESSING // Being classified/indexed
  INDEXED // Fully processed and indexed
  ERROR // Processing failed
  ARCHIVED // Archived/deleted
}

model ComplianceCheck {
  id         String   @id @default(cuid())
  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  policyId    String? // Reference to policy
  policyName  String
  requirement String // What requirement is being checked
  status      ComplianceStatus @default(PENDING)

  result    Json? // Check results
  notes     String?  @db.Text
  checkedBy String? // User ID
  checkedAt DateTime @default(now())

  @@index([documentId])
  @@index([status])
}

enum ComplianceStatus {
  PENDING
  COMPLIANT
  NON_COMPLIANT
  NEEDS_REVIEW
}

model DocumentQuestion {
  id         String    @id @default(cuid())
  documentId String?
  document   Document? @relation(fields: [documentId], references: [id], onDelete: SetNull)

  question String  @db.Text
  answer   String? @db.Text // AI-generated answer
  sources  Json? // Array of { documentId, excerpt, page } citations

  askedBy    String? // User ID
  answeredAt DateTime?
  createdAt  DateTime  @default(now())

  @@index([documentId])
}

model Policy {
  id          String  @id @default(cuid())
  name        String
  description String? @db.Text
  category    String // "regulation", "internal", "legal", etc.

  rules        Json // Policy rules definition
  requirements Json // Requirements checklist

  effectiveDate DateTime?
  expiryDate    DateTime?

  documents Document[]

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([isActive])
}

model Regulation {
  id        String @id @default(cuid())
  name      String
  authority String // "FI", "SKV", "EU", etc.
  category  String // "AML", "KYC", "tax", etc.

  content     String? @db.Text // Full text or summary
  externalUrl String? // Link to official source

  effectiveDate DateTime?
  updatedDate   DateTime?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([authority])
  @@index([category])
  @@index([isActive])
}

// ============================================================================
// AI KNOWLEDGE BASE & MODEL MANAGEMENT
// ============================================================================

model AIModel {
  id          String   @id @default(cuid())
  name        String // e.g. "bank-recon-expert"
  version     String // e.g. "1.2.0"
  description String?
  taskKind    TaskKind // Which task type this model handles

  prompts   AIModelPrompt[]
  examples  AIModelExample[]
  feedbacks AIFeedback[]

  settings  Json? // { verbosity: "high", reasoning_effort: "medium" } // reasoning_effort: "low" | "medium" | "high"
  isActive  Boolean @default(true)
  isDefault Boolean @default(false) // Only one default per taskKind

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // User ID who created this

  @@unique([name, version])
  @@index([taskKind, isActive])
  @@index([isDefault])
}

model AIModelPrompt {
  id      String  @id @default(cuid())
  modelId String
  model   AIModel @relation(fields: [modelId], references: [id], onDelete: Cascade)

  role    String // "system" | "user" | "assistant"
  content String @db.Text // Prompt text (can be long)
  order   Int // Order in messages array

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([modelId, order])
}

model AIModelExample {
  id      String  @id @default(cuid())
  modelId String
  model   AIModel @relation(fields: [modelId], references: [id], onDelete: Cascade)

  name   String? // Human-readable name for this example
  input  Json // Example input (structure varies by taskKind)
  output Json // Expected output
  tags   String[] // ["timing-difference", "high-amount", "common-case"]

  usageCount  Int       @default(0) // How many times used
  successRate Float? // 0.0-1.0: How often this gives correct results
  lastUsedAt  DateTime?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([modelId, isActive])
  @@index([modelId, tags])
}

model AIFeedback {
  id      String  @id @default(cuid())
  modelId String
  model   AIModel @relation(fields: [modelId], references: [id], onDelete: Cascade)

  userId String? // User who provided feedback
  taskId String? // Related task if applicable

  rating     Int // 1-5: How good was the response?
  wasCorrect Boolean? // Was the output correct?
  comment    String?  @db.Text // User feedback text

  input    Json? // What was the input?
  output   Json? // What was the actual output?
  expected Json? // What was expected (if provided)?

  createdAt      DateTime         @default(now())
  AIConversation AIConversation[]

  @@index([modelId, createdAt])
  @@index([modelId, wasCorrect])
  @@index([userId])
}

model AIKnowledgeBase {
  id       String   @id @default(cuid())
  category String // "workflow" | "regulation" | "common-issues" | "best-practices"
  title    String
  content  String   @db.Text // Markdown content
  tags     String[]

  // Metadata
  views      Int @default(0)
  helpful    Int @default(0)
  notHelpful Int @default(0)

  // Embedding for RAG (future)
  embedding String? // Vector embedding (when implementing RAG)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // User ID

  @@index([category, isActive])
  @@index([tags])
}

model AIConversation {
  id     String @id @default(cuid())
  userId String
  user   User   @relation("UserConversations", fields: [userId], references: [id])

  modelId  String? // Which AI model was used
  messages Json // Array of { role, content, timestamp }

  feedback AIFeedback? @relation(fields: [aIFeedbackId], references: [id])

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  aIFeedbackId String?

  @@index([userId, createdAt])
  @@index([modelId])
}
